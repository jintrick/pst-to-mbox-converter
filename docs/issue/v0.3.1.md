# Issue v0.3.1: libpffライブラリの同梱と動的ロードパスの実装

## 前提知識
- spec_v2.md
- docs/issue/v0.3.0.md

## 現状の問題点
`issue/v0.3.0` の実装により、プロジェクトは `ctypes` を介して `libpff` を直接利用するようになりました。しかし、これはツールの実行環境に `libpff` の共有ライブラリ (`.dll`, `.so` など) が事前にインストールされていることを前提としています。

特にWindowsユーザーにとって、`libpff.dll` を手動でダウンロードし、システムの適切なパスに配置するのは技術的なハードルが高く、ツールの利便性を著しく損なっています。

## 解決策の概要
ツールの使いやすさを向上させるため、`libpff` ライブラリをプロジェクトに同梱し、アプリケーションが自己完結して動作できるようにします。

`pst_reader.py` のライブラリ読み込み処理を改修し、まずプロジェクト内の同梱ライブラリを探し、見つからない場合にのみシステムにインストールされたライブラリを探しにいく、というフォールバック機構を実装します。

## 解決策の詳細
1.  **ライブラリ格納ディレクトリの規約定義**
    -   コンパイル済みの共有ライブラリを格納するため、ソースパッケージ内に以下のディレクトリ構造を設けます。
    -   `src/pst_to_mbox_converter/libs/windows/64bit/libpff.dll`
    -   `src/pst_to_mbox_converter/libs/windows/32bit/libpff.dll`

2.  **`pst_reader.py` の動的ロード処理の実装**
    -   ファイルの先頭にあるライブラリ検索ロジックを、`find_libpff()` のような関数にまとめ、以下の処理を実装します。
    -   `platform` モジュールを使い、現在のOSとCPUアーキテクチャを判別します。
    -   まず、上記で定義した同梱ライブラリのパスを構築し、ファイルが存在するか確認します。
    -   ファイルが存在すれば、そのパスを返します。
    -   存在しない場合、従来通り `ctypes.util.find_library()` を使ってシステムパスを検索し、その結果を返します。
    -   ライブラリが最終的に見つからなかった場合の `ImportError` のメッセージを、「システムにインストールするか、アプリケーションに同梱されていることを確認してください」という趣旨の、より親切な内容に更新します。

## 受け入れ条件 (Acceptance Criteria)
- `pst_reader.py` に、同梱ライブラリを優先的に読み込むロジックが実装されていること。
- `libpff.dll` を `src/pst_to_mbox_converter/libs/` 以下に配置した場合、`libpff` がシステムにインストールされていないWindows環境でもツールが正常に動作すること。
- 同梱ライブラリが存在しない場合でも、システムに `libpff` がインストールされていればツールが正常に動作すること。
- `pytest` を実行した際に、すべてのテストが正常に完了すること。

## 参考とすべきスクリプト等

## マージ先ブランチ
このIssueのPRは `develop/0.3.1` ブランチに向けて作成してください。


